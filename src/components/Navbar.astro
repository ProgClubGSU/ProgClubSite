---
import { SITE_TITLE, NAV_LINKS as links } from "@/consts";
---

<!-- Minimal Clean Navigation -->
<nav class="fixed top-0 left-0 w-full h-full pointer-events-none !z-[9999]">
  <style>
    html {
      scroll-behavior: smooth;
    }
  </style>

  <!-- Navigation Links - Dynamic Layout -->
  <div id="nav-links" class="absolute top-1/2 left-4 md:left-8 transform -translate-y-1/2 pointer-events-auto">
    <div class="hidden md:flex flex-col space-y-4" id="nav-container" style="font-family: 'Helvetica Neue', sans-serif;">
      {
        links.map((link, index) => {
          if (link.children && link.children.length > 0) {
            // Dropdown menu item
            return (
              <div class="relative group nav-link" data-index={index} style="transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);">
                <button class="text-white/60 hover:text-white text-lg font-light flex items-center gap-1">
                  {link.title.toLowerCase()}
                  <span class="text-xs opacity-60">â–¼</span>
                  </button>
                {/* Dropdown Menu */}
                <div class="absolute left-0 top-8 bg-black/90 backdrop-blur-sm border border-white/10 rounded-sm opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 min-w-[140px] z-50">
                    {link.children.map((child) => {
                      const childHref = child.href ?? child.title.toLowerCase().replaceAll(" ", "-");
                    const isExternalLink = childHref.startsWith("http://") || childHref.startsWith("https://");
                    const finalChildHref = isExternalLink ? childHref : childHref.startsWith('/') ? childHref : `/${childHref}`;
                      return (
                        <a
                        href={finalChildHref}
                        target={isExternalLink ? "_blank" : undefined}
                        rel={isExternalLink ? "noopener noreferrer" : undefined}
                        class="block px-4 py-2 text-white/60 hover:text-white hover:bg-white/5 text-sm font-light transition-colors duration-150"
                      >
                        {child.title.toLowerCase()}
                        </a>
                      );
                    })}
                  </div>
                </div>
            );
          } else {
            // Regular menu item
            const href = link.href ?? link.title.toLowerCase().replaceAll(" ", "-");
            const pathname = Astro.url.pathname.replace(import.meta.env.BASE_URL, "");
            const subpath = pathname.match(/[^\/]+/g);
            const isActive = href === pathname || href === "/" + (subpath?.[0] || "");
            const isExternalLink = href.startsWith("http://") || href.startsWith("https://");
            const finalHref = isExternalLink ? href : href;
            return (
              <a
                class:list={[{ "text-white": isActive }]}
                class="text-white/60 hover:text-white text-lg font-light nav-link block"
                href={finalHref}
                target={isExternalLink ? "_blank" : undefined}
                rel={isExternalLink ? "noopener noreferrer" : undefined}
              >
                {link.title.toLowerCase()}
              </a>
            );
          }
        })
      }
      {/* Contact button */}
      <a href="#contact" class="text-white/60 hover:text-white text-lg font-light nav-link block transition-colors duration-150">
        contact
      </a>
    </div>
    </div>

  <!-- Mobile Menu Button -->
  <div class="md:hidden absolute top-4 right-4 pointer-events-auto">
    <button
      id="mobile-menu-btn"
      class="w-10 h-10 bg-white/10 hover:bg-white/20 rounded-full flex items-center justify-center transition-colors duration-300"
      aria-label="Toggle mobile menu"
    >
      <div class="w-4 h-4 flex flex-col justify-center items-center">
        <span class="w-3 h-0.5 bg-white mb-1"></span>
        <span class="w-3 h-0.5 bg-white mb-1"></span>
        <span class="w-3 h-0.5 bg-white"></span>
      </div>
    </button>
  </div>

  <!-- Mobile Menu Overlay -->
  <div
    id="mobile-menu"
    class="md:hidden fixed inset-0 bg-black/95 backdrop-blur-md opacity-0 invisible transition-all duration-300 pointer-events-none"
    style="font-family: 'Helvetica Neue', sans-serif;"
  >
    <div class="flex flex-col items-center justify-center h-full space-y-8">
      {
        links.map((link) => {
          const href = link.href ?? link.title.toLowerCase().replaceAll(" ", "-");
          const pathname = Astro.url.pathname.replace(import.meta.env.BASE_URL, "");
          const subpath = pathname.match(/[^\/]+/g);
          const isActive = href === pathname || href === "/" + (subpath?.[0] || "");
          const isExternalLink = href.startsWith("http://") || href.startsWith("https://");
          const finalHref = isExternalLink ? href : `/${href}`;
          return (
            <a
              class:list={[{ "text-white": isActive }]}
              class="text-white/60 hover:text-white text-xl font-light transition-colors duration-300"
              href={finalHref}
              target={isExternalLink ? "_blank" : undefined}
              rel={isExternalLink ? "noopener noreferrer" : undefined}
            >
              {link.title.toLowerCase()}
            </a>
          );
        })
      }
      {/* Contact button for mobile */}
      <a href="#contact" class="text-white/60 hover:text-white text-xl font-light transition-colors duration-300">
        contact
      </a>
    </div>
  </div>
</nav>

<script>
  // Mobile menu toggle and rotating progsu
  document.addEventListener('DOMContentLoaded', () => {
    const mobileMenuBtn = document.getElementById('mobile-menu-btn');
    const mobileMenu = document.getElementById('mobile-menu');
    // Get the hero progsu element from Hero.astro
    const heroProgsu = document.getElementById('hero-progsu');

    // Mobile menu toggle
    if (mobileMenuBtn && mobileMenu) {
      mobileMenuBtn.addEventListener('click', () => {
        const isOpen = mobileMenu.classList.contains('opacity-100');
        
        if (isOpen) {
          mobileMenu.classList.remove('opacity-100', 'visible', 'pointer-events-auto');
          mobileMenu.classList.add('opacity-0', 'invisible', 'pointer-events-none');
        } else {
          mobileMenu.classList.remove('opacity-0', 'invisible', 'pointer-events-none');
          mobileMenu.classList.add('opacity-100', 'visible', 'pointer-events-auto');
        }
      });
    }

    // Rotating progsu functionality
    if (heroProgsu) {
      let logoTransitioned = false;
      const heroHeight = window.innerHeight * 0.75;
      
      // Smooth scroll-following progsu transformation
      const updateHeroProgsuPosition = () => {
        if (!heroProgsu) return;
        
        const scrollY = window.scrollY;
        const startTransition = heroHeight * 0.2; // Start earlier for smoother transition
        const endTransition = heroHeight * 0.8;   // End later for more gradual change
        
        // Get the original hero position (relative to viewport when not scrolled)
        const heroContainer = heroProgsu.parentElement;
        const heroRect = heroContainer.getBoundingClientRect();
        const originalLeft = heroRect.left + 32; // Account for hero's left padding
        const originalTop = heroRect.top + 32;   // Account for hero's top padding
        
        if (scrollY < startTransition) {
          // Reset to normal hero position
          if (logoTransitioned) {
            logoTransitioned = false;
            heroProgsu.style.position = 'static';
            heroProgsu.style.left = 'auto';
            heroProgsu.style.top = 'auto';
            heroProgsu.style.transform = 'none';
            heroProgsu.style.transformOrigin = 'initial';
            heroProgsu.style.zIndex = 'auto';
            heroProgsu.style.fontSize = '';
          }
        } else {
          // Start transition - make it fixed and animate
          if (!logoTransitioned) {
            logoTransitioned = true;
            heroProgsu.style.position = 'fixed';
            heroProgsu.style.zIndex = '10000';
            heroProgsu.style.transformOrigin = 'left center';
          }
          
          if (scrollY <= endTransition) {
            // Transition phase - smooth interpolation from current visible position
            const progress = (scrollY - startTransition) / (endTransition - startTransition);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out
            
            // Calculate current position (where it would be if still in hero)
            const currentHeroTop = originalTop - scrollY;
            
              // Target position (much lower on screen, closer to left edge)
              const endLeft = 48;  // 3rem in pixels - closer to edge but not clipped
              const endTop = 120;  // 7.5rem in pixels - much lower
              
              // Smooth interpolation from current hero position to target
              const currentLeft = originalLeft + (endLeft - originalLeft) * easeProgress;
              const currentTop = currentHeroTop + (endTop - currentHeroTop) * easeProgress;
              
              // Interpolate rotation (0 to -90 degrees)
              const rotation = -90 * easeProgress;
              
              // Interpolate size
              const fontSize = 1.5 + (0.5 * easeProgress); // 1.5rem to 2rem
              
              heroProgsu.style.left = `${currentLeft}px`;
              heroProgsu.style.top = `${currentTop}px`;
              heroProgsu.style.transform = `rotate(${rotation}deg)`;
              heroProgsu.style.transformOrigin = 'left center'; // Ensure consistent rotation point
              heroProgsu.style.fontSize = `${fontSize}rem`;
            
          } else {
            // Final sticky position - much lower, closer to left edge
            heroProgsu.style.left = '3rem'; // Closer to edge but not clipped
            heroProgsu.style.top = '7.5rem'; // Much lower - 120px from top
            heroProgsu.style.transform = 'rotate(-90deg)';
            heroProgsu.style.transformOrigin = 'left center'; // Consistent rotation point
            heroProgsu.style.fontSize = '2rem';
          }
        }
      };
      
      // Initial check
      updateHeroProgsuPosition();
      
      // Throttled scroll listener for progsu rotation
      let ticking = false;
      const throttledScroll = () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateHeroProgsuPosition();
            ticking = false;
          });
          ticking = true;
        }
      };

      window.addEventListener('scroll', throttledScroll, { passive: true });
    }
  });
</script>